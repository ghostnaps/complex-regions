[{"title":"Contributing","type":0,"sectionRef":"#","url":"docs/contributing","content":"","keywords":""},{"title":"Getting Started​","type":1,"pageTitle":"Contributing","url":"docs/contributing#getting-started","content":""},{"title":"VS Code​","type":1,"pageTitle":"Contributing","url":"docs/contributing#vs-code","content":"You should be using Visual Studio Code as your text editor and have the following extensions installed: RojoSeleneStyLua Once installed, the Rojo extension will display a welcome screen. Scroll down to the section for the Roblox Studio plugin and select &quot;Manage it for me.&quot; Next time you open a place in Studio you will have the Rojo plugin ready to go. "},{"title":"Foreman​","type":1,"pageTitle":"Contributing","url":"docs/contributing#foreman","content":"Foreman handles the installation of several of our other tools, like Rojo, Wally, Selene, and StyLua. To install through Cargo, run the following: cargo install foreman Copy note The cargo command is a part of Rust. If you don't wish to install Rust on your device you can get the latest Foreman binary from the releases page. To make the tools that Foreman installs avialable on your system you will also need to manually add its bin folder to your PATH: Windows Add C:\\Users\\You\\.foreman\\bin to your PATHFollow this guide for how to do that MacOS Open TerminalOpen the corresponding file for your terminal Bash: nano ~/.bash_profileZSH: nano ~/.zshrc Append export PATH=&quot;$PATH:~/.foreman/bin to the end of the file tip Changes to the PATH will only take effect in new terminals. If you are not able to invoke the tools that Foreman manages, try closing and reopening your terminal. "},{"title":"Development​","type":1,"pageTitle":"Contributing","url":"docs/contributing#development","content":"With the above requirements satisfied, run the following commands from your clone of this repository to start developing: # Install Rojo, Wally, Selene, StyLua, and others foreman install # Install this package's dependencie wally install # Serve the project rojo serve dev.project.json Copy Now you can open Studio to a new Baseplate and start syncing with the Rojo plugin. "},{"title":"Testing​","type":1,"pageTitle":"Contributing","url":"docs/contributing#testing","content":"While developing, you should also be writing unit tests. Unit tests are written in .spec.lua files. You can see examples of this throughout the repository's codebase. To run tests, simply start the experience in Studio. You will see in the output if tests are passing or failing. If your code is not properly tested, maintainers will let you know and offer suggestions on how to improve your tests so you can get your pull request merged. "},{"title":"Getting Started","type":0,"sectionRef":"#","url":"docs/intro","content":"","keywords":""},{"title":"Installation​","type":1,"pageTitle":"Getting Started","url":"docs/intro#installation","content":"Installing the package is quick and easy whether you use a package manager like Wally or work directly in Studio. "},{"title":"Wally (Recommended)​","type":1,"pageTitle":"Getting Started","url":"docs/intro#wally-recommended","content":"Add the following to your wally.toml and run wally install to download the package. [dependencies] ComplexRegions = &quot;vocksel/complex-regions@0.1.1&quot; Copy Make sure the resulting Packages folder is synced into your experience using a tool like Rojo. "},{"title":"Roblox Studio​","type":1,"pageTitle":"Getting Started","url":"docs/intro#roblox-studio","content":"Download a copy of the rbxm from the releases page under the Assets section.Drag and drop the file into Roblox Studio to add it to your experience. "},{"title":"Next Steps​","type":1,"pageTitle":"Getting Started","url":"docs/intro#next-steps","content":"Check out the API reference for everything that the package exposes. "},{"title":"Creating Regions","type":0,"sectionRef":"#","url":"docs/creating-regions","content":"Creating Regions A region can be a singular BasePart instance, or a Model containing several BaseParts that make up the region. The latter is where this package shines. To create a region add a new Model into the Workspace, rename it to Region, and add some Parts inside of it. Make sure to set CanCollide = false for each Part so that other instances can enter the region. Next, create a new LocalScript in StarterPlayerScripts with the following contents: local Players = game:GetService(&quot;Players&quot;) local ReplicatedStorage = game:GetService(&quot;ReplicatedStorage&quot;) local ComplexRegions = require(ReplicatedStorage.Packages.ComplexRegions) local region = ComplexRegions.Region.new(workspace.Region) -- The whitelist determines which instances can interact with the region. In -- this case, we will respond when our Character enters. region:setWhitelist({ Players.LocalPlayer.Character }) -- This starts up a Heartbeat connection and is required for the region to -- respond to instances in the whitelist entering and leaving. region:listen() region.entered:Connect(function(character: Model) print(character, &quot;entered&quot;, region) end) region.left:Connect(function(character: Model) print(character, &quot;left&quot;, region) end) Copy Now when you start the experience and walk in and out of the region messages will print in the output.","keywords":""},{"title":"ComplexRegions","type":0,"sectionRef":"#","url":"api/ComplexRegions","content":"","keywords":""},{"title":"Properties​","type":1,"pageTitle":"ComplexRegions","url":"api/ComplexRegions#properties","content":" "},{"title":"Region​","type":1,"pageTitle":"ComplexRegions","url":"api/ComplexRegions#Region","content":"&lt;/&gt; ComplexRegions.Region: Region The Region class is exposed on the API but should typically be instantiated with the createRegion function. local regionInstance = Instance.new(&quot;Part&quot;) local region = ComplexRegions.Region.new(regionInstance)  "},{"title":"Functions​","type":1,"pageTitle":"ComplexRegions","url":"api/ComplexRegions#functions","content":" "},{"title":"createRegion​","type":1,"pageTitle":"ComplexRegions","url":"api/ComplexRegions#createRegion","content":"&lt;/&gt; ComplexRegions.createRegion( regionInstance: Model | BasePart ,-- The instance that represents the region whitelist: {Instance }-- Array of Instances that will trigger the region's events ) → Region Helper function that will create a Region, set its whitelist, and also listen for instances entering and leaving. Usage: local region = ComplexRegions.createRegion(workspace.Region, { Players.LocalPlayer.Character }) region.entered:Connect(function(instance: Instance) print(instance, &quot;entered the region&quot;) end) region.left:Connect(function(instance: Instance) print(instance, &quot;left the region&quot;) end)  "},{"title":"Region","type":0,"sectionRef":"#","url":"api/Region","content":"","keywords":""},{"title":"Types​","type":1,"pageTitle":"Region","url":"api/Region#types","content":" "},{"title":"RegionInstance​","type":1,"pageTitle":"Region","url":"api/Region#RegionInstance","content":"&lt;/&gt; type RegionInstance = BasePart | Model  The 3D representation of the Region's boundaries. It can either be a single BasePart or a Model composed of several BaseParts that all represent one Region. "},{"title":"Properties​","type":1,"pageTitle":"Region","url":"api/Region#properties","content":" "},{"title":"name​","type":1,"pageTitle":"Region","url":"api/Region#name","content":"&lt;/&gt; Region.name: string The name of the Region. This is used when calling tostring() on the Region instance. (Default: &quot;Region&quot;)  "},{"title":"instance​","type":1,"pageTitle":"Region","url":"api/Region#instance","content":"&lt;/&gt; Region.instance: RegionInstance A reference to the regionInstance argument pass when constructing  "},{"title":"entered​","type":1,"pageTitle":"Region","url":"api/Region#entered","content":"&lt;/&gt; Region.entered: RBXScriptSignal  Fired when an instance in the whitelist enters the Region. local regionInstance = Instance.new(&quot;Part&quot;) local region = Region.new(regionInstance) region.entered:Connect(function(instance: Instance) print(instance, &quot;entered the region&quot;) end)   "},{"title":"left​","type":1,"pageTitle":"Region","url":"api/Region#left","content":"&lt;/&gt; Region.left: RBXScriptSignal  Fired when an instance in the whitelist leaves the Region. Usage: local regionInstance = Instance.new(&quot;Part&quot;) local region = Region.new(regionInstance) region.left:Connect(function(instance: Instance) print(instance, &quot;left the region&quot;) end)  "},{"title":"Functions​","type":1,"pageTitle":"Region","url":"api/Region#functions","content":" "},{"title":"new​","type":1,"pageTitle":"Region","url":"api/Region#new","content":"&lt;/&gt; Region.new(regionInstance: RegionInstance) → Region Constructs a new Region instance. You can either pass in a Model or a BasePart which will represent the Region's boundaries in the Workspace. When using a Model, it must contain BaseParts as children. A Region's BaseParts are known as &quot;segments.&quot; Every Region must have at least one segment, and when a segment is collided with by instances in the whitelist certain events will be triggered. local regionInstance = Instance.new(&quot;Part&quot;) local region = Region.new(regionInstance)   "},{"title":"is​","type":1,"pageTitle":"Region","url":"api/Region#is","content":"&lt;/&gt; Region.is(other: any) → boolean-- Returns true if other is a Region, false otherwise Static function for checking if the given argument is a Region instance or not. local regionInstance = Instance.new(&quot;Part&quot;) local region = Region.new(regionInstance) print(Region.is(region)) -- true print(Region.is(&quot;string&quot;) -- false   "},{"title":"setWhitelist​","type":1,"pageTitle":"Region","url":"api/Region#setWhitelist","content":"&lt;/&gt; Region:setWhitelist(whitelist: {Instance }) → () Sets the instances that can collide with the Region and trigger events. The whitelist must be defined or the Region will not respond to any instances. tip A common use case is to set the whitelist to all the Character models in the Workspace. This allows you to setup a region system where your players can enter and leave specific zones. local regionInstance = Instance.new(&quot;Part&quot;) local region = Region.new(regionInstance) region:setWhitelist({ Players.LocalPlayer.Character })   "},{"title":"getRegionSegments​","type":1,"pageTitle":"Region","url":"api/Region#getRegionSegments","content":"&lt;/&gt; Region:getRegionSegments() → {BasePart }-- Returns all BaseParts that compose the Region Get all of the BaseParts that compose the Region's boundary. info If you passed in a BasePart when constructing, this will return an array with that BasePart as the only element. If you passed a Model, this will return an array with all BasePart descendants. local regionInstance = Instance.new(&quot;Part&quot;) local region = Region.new(regionInstance) print(region:getRegionSegments())   "},{"title":"getInstancesInRegion​","type":1,"pageTitle":"Region","url":"api/Region#getInstancesInRegion","content":"&lt;/&gt; Region:getInstancesInRegion() → {Instance }-- Array of whitelisted Instances that are within the Region Gets all whitelisted Instances that are within the Region. tip The below example uses a while loop to print out all whitelisted instances within the Region for illustrative purposes. Usually you will want to respond to the enter and left events. local regionInstance = Instance.new(&quot;Part&quot;) local region = Region.new(regionInstance) region:setWhitelist({ Players.LocalPlayer.Character }) region:listen() while task.wait(1) do print(region:getInstancesInRegion()) end   "},{"title":"isInstanceInRegion​","type":1,"pageTitle":"Region","url":"api/Region#isInstanceInRegion","content":"&lt;/&gt; Region:isInstanceInRegion(instance: Instance ) → boolean-- Returns true if the Instance is within the Region, false otherwise Checks if the given Instance is within the Region. This only applies to instances in the whitelist. If you call this function on an instance that is not whitelisted, it will always return false. local regionInstance = Instance.new(&quot;Part&quot;) local region = Region.new(regionInstance) region:setWhitelist({ workspace.Part }) region:listen() while task.wait(1) do print(region:isInstanceInRegion(workspace.Part)) end   "},{"title":"listen​","type":1,"pageTitle":"Region","url":"api/Region#listen","content":"&lt;/&gt; Region:listen() → () Starts a Heartbeat connection to listen for instances in the whitelist colliding with the Region. This method must be called before instances in the whitelist will be detected within the Region's boundaries. local regionInstance = Instance.new(&quot;Part&quot;) local region = Region.new(regionInstance) region:setWhitelist({ Players.LocalPlayer.Character }) region:listen()   "},{"title":"destroy​","type":1,"pageTitle":"Region","url":"api/Region#destroy","content":"&lt;/&gt; Region:destroy() → () Destroys the Region, cleaning up any connections and destroying Instances that the Region relied on. Note that this will destroy regionInstance. local regionInstance = Instance.new(&quot;Part&quot;) local region = Region.new(regionInstance) region:setWhitelist({ workspace.Part }) region:listen() -- Later... region:destroy() print(regionInstance.Parent) -- nil  "}]